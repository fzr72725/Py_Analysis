Note/Cheatsheet:
1. df.pivot_table('prop',index='year',columns='sex',aggfunc=sum)
or
df.pivot_table('births',index=last_letters,columns=['sex','year'],aggfunc=sum)
*Turns column values in different rows into column names
2. df.sort_values(by='prop',ascending=False)
*Sorts a dataframe by certain column
3. pd.plot(subplots=True,figsize=(12,10),grid=False,title="Number of births per year")
*Plot each Series in the dataframe
4. df.groupby(['year','sex'])
*Turn dataframe into certain groups using columns
5. df.concat(pieces, ignore_index=True)
*Merge multiple dataframes into one
6. np.cumsum(a=columnA)/df.columnA.cumsum()
*Calculate the cumulative sum of columnA
7. np.searchsorted(array,value)/Series.searchsorted(value)
*Return the index of the given value in the array/Serirs
8. def get_top1000(group):
       return group.sort_values(by='births',ascending=False)[:1000]
    
   top1000 = names.groupby(['year','sex']).apply(get_top1000)
*Define a function that will make changes to each group, then "groupby" a datagrame, then apply the defined function to each group in the GroupBy ojbect
9. get_last_letter = lambda x: x[:-1]
last_letters = names.name.map(get_last_letter)
*Using lambda to define a function, then run the function using map()
10. df.reindex(columns=[1910,1960,2010],level='year')
*Since years are the second level columns, it's hard to use column names to get the subset, so reindex can set the column level and get the subset
11. 
import matplotlib.pyplot as plt
figs, axes = plt.subplots(2,1,figsize=(10,8)) # 2,1 means 2x1 grid
letter_prop['M'].plot(kind='bar',rot=0,ax=axes[0],title='Male')
letter_prop['F'].plot(kind='bar',rot=0,ax=axes[1],title='Female',legend=False)
*When there are multiple levels of columns, pandas.plot cannot handle it, we can use matplotlib to do it by setting the subplots separately. 
12. letter_drop.ix[['d','n','y'],'M'].T
* ix can use either label or index to access dataframe rows
13. Series.values
Series.index
obj = Series([4,5,-7,3],index=['d','a','b','c'])
* Creates a Series object with specific index, this is desirable
14. sdata = {'Ohio': 35000, 'Texas': 71000, 'Oregon': 16000, 'Utah': 5000}
obj = Series(sdata)
*Create a Series object based on a dictionary, the dictionary key will be turned into index. A Series object can be treated as dictionary
15. pd.isnull(<a Series object>)
*Returns a Series object of boolean values, index of the examined Series object is still the index of the result Series object
16. 
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002],
'pop': [1.5, 1.7, 3.6, 2.4, 2.9]}
frame = DataFrame(data)
*Creates dataframe from dictionaries with lists that have equal length, and you can specify the sequence of the columns by doing this: frame = DataFrame(data, columns=['year','state','pop'])
17. frame2['state']
frame2.year
*Two ways of retrieving a column from a dataframe
18. dataframe.T
* Tranposes the dataframe, meaning switch columns and rows
19. df.describe()
*Returns a bunch of statistical information about a dataframe values
20. dataframe.pct_change()
*Calculate the percent change in the dataframe for all columns
21.Series1.corr(Series2); Series1.cov(Series2)
*corr() Calculates the correlation of the two series(or two columns of a dataframe)
*cov() Calculates the covariance of the two series(or two columns of a dataframe)
22. DataFrame.corr();DataFrame.cov()
* similar to above, but return the whole matrix of all columns
23. DataFrame.isnull()/DataFrame.notnull()/DataFrame.dropna()/DataFrame.fillna()
* how dataframe deals with missing values
* missing value can be set using "np.nan"
24. DataFrame.fillna(DataFrame.mean())
* Fill na values with the mean of the data
25. dataframe.unstack()
* transform a multiple hierachy indexing dataframe into a one-level dataframe
26. JSON:
All keys in json object must be strings.

p168

